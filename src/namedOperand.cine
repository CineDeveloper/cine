type NamedOperand
    level UInt64
    operand Operand
    enslaved Bool

func deleteLevel(:namedOperands, compilingFunction, level, :registersCount, :waitingFunctions, data, :compiledData)
    rules
        1 = namedOperands == Map([UInt8], NamedOperand) & compilingFunction == CompiledFunction
        2 = level == UInt64 & registersCount == UInt64 & waitingFunctions == [Pair(Function, [Operand])]
        3 = data == Data & compiledData == CompiledData
        final = 1 & 2 & 3
        result = [UInt8]
    result = namedOperands.freeOperands(compilingFunction, level, registersCount, waitingFunctions, data, compiledData)
    namedOperands:deleteOperands(level)

func freeOperands(namedOperands, compilingFunction, level, :registersCount, :waitingFunctions, data, :compiledData)
    rules
        1 = namedOperands == Map([UInt8], NamedOperand) & compilingFunction == CompiledFunction
        2 = level == UInt64 & registersCount == UInt64 & waitingFunctions == [Pair(Function, [Operand])]
        3 = data == Data & compiledData == CompiledData
        final = 1 & 2 & 3
        result = [UInt8]
    parse _, namedOperand <- namedOperands
        if namedOperand.level >= level
            then if !namedOperand.enslaved
                then result += namedOperand.operand.freeOperand(compilingFunction, registersCount, waitingFunctions, data, compiledData)

proc deleteOperands(:namedOperands, level)
    rules
        final = namedOperands == Map([UInt8], NamedOperand) & level == UInt64
    newNamedOperands := Map([UInt8], NamedOperand)
    parse name, namedOperand <- namedOperands
        if namedOperand.level < level
            then newNamedOperands:add(name, namedOperand)
    namedOperands = newNamedOperands
