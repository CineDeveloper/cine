type Operand
    value, cType [UInt8]
    expressionForErrors Token
    type OperandType
    typeNumber UInt64
    mutable, constant, haveLink, static Bool

func toReadOnly(operand Operand) Operand
    result = operand
    if result.mutable
        then
            result:mutable = false
            result:value = select(result.value[0] == '&', result.value.getAllExceptFirst(), "(*".join(result.value, ")"))

func getMainObjectName(operand Operand) [UInt8]
    beginIndex := 0
    endEdge := 0
    if !operand.value.contain?('{')
        then
            parse index, char <- operand.value
                if char.fromName?()
                    then
                        beginIndex = index
                        break
            endEdge = operand.value.getLength() - beginIndex - 1
            parse index, char <- operand.value.getAllExceptFirstN(beginIndex + 1)
                if !char.fromName?()
                    then
                        endEdge = index
                        break
            endEdge += beginIndex + 1
            result = operand.value.getSlice(beginIndex, endEdge)

func createNewRegister(:registersCount UInt64, mutable Bool, cType [UInt8], value [UInt8]) Pair([UInt8], [UInt8])
    attributes
        alwaysInline
    result:second = "__r" + registersCount.toString()
    result:first = "\t".join(cType, select(mutable, " ", " const "), result:second)
    if value != ""
        then result:first:join(" = ", value)
    result:first += ";\n"
    registersCount++

func freeOperands(:tmpOperands Map([UInt8], Operand), :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) [UInt8]
    if tmpOperands.getLength() != 0
        then
            parse _, operand <- tmpOperands
                result += operand.freeOperand(registersCount, waitingFunctions, data, compiledData)
            tmpOperands = #tmpOperands

func toOperandsTypes(operands [Operand]) [OperandType]
    attributes
        alwaysInline
    parse _, operand <- operands
        result += operand.type

proc put(:tmpOperands Map([UInt8], Operand), operand Operand)
    if operand.value != ""
        then tmpOperands:add(operand.value, operand)

func useOperand(operand Operand, :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) [UInt8]
    if operand.haveLink && !(operand.constant || operand.type.function?())
        then
            roOperand .= operand.toReadOnly()
            result = FunctionInExpression{name: operand.expressionForErrors.replaceValue("use"), arguments: [FunctionExpression]{FunctionExpression{expression: [Fluid]{roOperand.toFluid()}}}}{
                .toOperand(registersCount, waitingFunctions, false, data, compiledData).first
            }

func freeOperand(operand Operand, :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) [UInt8]
    if operand.haveLink && !(operand.constant || operand.type.function?())
        then
            roOperand .= operand.toReadOnly()
            result = FunctionInExpression{name: roOperand.expressionForErrors.replaceValue("free"), arguments: [FunctionExpression]{FunctionExpression{expression: [Fluid]{roOperand.toFluid()}}}}{
                .toOperand(registersCount, waitingFunctions, false, data, compiledData).first
            }

func cloneMembers(operand Operand, :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) Pair([UInt8], Operand)
    operandType .= operand.type.compile(data, compiledData)
    code_register .= registersCount:createNewRegister(true, operand.cType, "(".join(operand.cType, "){0}"))
    code := code_register.first
    parse name, type <- operandType.members
        memberType .= type.compile(data, compiledData)
        memberOperand .= Operand{{
            value: "(".join(operand.value, ").", name, "_"),
            cType: memberType.cType,
            expressionForErrors: operand.expressionForErrors,
            type: type,
            typeNumber: memberType.typeNumber,
            haveLink: memberType.haveLink}
        }
        code_clonedMember .= FunctionInExpression{name: operand.expressionForErrors.replaceValue("clone"), arguments: [FunctionExpression]{FunctionExpression{expression: [Fluid]{memberOperand.toFluid()}}}}{
            .toOperand(registersCount, waitingFunctions, true, data, compiledData)
        }
        code:join(code_clonedMember.first, "\t", code_register.second, ".", name, "_ = ", code_clonedMember.second.value, ";\n")
    resultOperand := operand
    resultOperand:value = code_register.second
    resultOperand:constant = false
    resultOperand:expressionForErrors:value = "clone(".join(resultOperand.expressionForErrors[], ")")
    result = #result.create(code, resultOperand)

func freeMembers(operand Operand, :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) [UInt8]
    operandType .= operand.type.compile(data, compiledData)
    parse name, type <- operandType.members
        memberType .= type.compile(data, compiledData)
        memberOperand .= Operand{{
            value: "(".join(operand.value, ").", name, "_"),
            cType: memberType.cType,
            expressionForErrors: operand.expressionForErrors,
            type: type,
            typeNumber: memberType.typeNumber,
            haveLink: memberType.haveLink}
        }
        result += memberOperand.freeOperand(registersCount, waitingFunctions, data, compiledData)

func useMembers(operand Operand, :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) [UInt8]
    operandType .= operand.type.compile(data, compiledData)
    parse name, type <- operandType.members
        memberType .= type.compile(data, compiledData)
        memberOperand .= Operand{{
            value: "(".join(operand.value, ").", name, "_"),
            cType: memberType.cType,
            expressionForErrors: operand.expressionForErrors,
            type: type,
            typeNumber: memberType.typeNumber,
            haveLink: memberType.haveLink}
        }
        result += memberOperand.useOperand(registersCount, waitingFunctions, data, compiledData)

func setOperand(destionation Operand, source Operand, :registersCount UInt64, :waitingFunctions [Pair(Function, [Operand])], data Data, :compiledData CompiledData) [UInt8]
    if < !destionation.mutable
        then errorExpectMutable(destionation.expressionForErrors)
    if < destionation.type != source.type
        then errorWrongType(source.expressionForErrors.replaceValue(source.type.toToken()[]))
    if destionation.haveLink
        then
            tmpOperand := destionation
            tmpOperand:mutable = false
            code_value .= registersCount:createNewRegister(false, destionation.cType, destionation.toReadOnly().value)
            result = code_value.first
            tmpOperand:value = code_value.second
            if destionation.value[0] == '&'
                then result:join("\t", destionation.value.getAllExceptFirst(), " = ")
                else result:join("\t*(", destionation.value, ") = ")
            if destionation.cType.getLast() == '*'
                then result:join("(", destionation.cType, ")(", source.value, ");\n")
                else result:join(source.value, ";\n")
            result += tmpOperand.freeOperand(registersCount, waitingFunctions, data, compiledData)
        else
            if destionation.value[0] == '&'
                then result:join("\t", destionation.value.getAllExceptFirst(), " = ")
                else result:join("\t*(", destionation.value, ") = ")
            result:join(source.value, ";\n")
